# --- v0_trajectory_plots.py ---

import numpy as np
import matplotlib.pyplot as plt
import os
import csv
from matplotlib import animation
from mpl_toolkits.mplot3d import Axes3D # Required for 3D projection
from matplotlib.colors import to_rgba
import matplotlib.patches as patches # For animation time bar

# Import constants
from v0_trajectory_constants_HPC import (
    BASE_RESULTS_DIR, TRAJECTORY_CSV_FILENAME, PLOT_OUTPUT_DIR_PREFIX,
    PLOT_ALL_RADII, PLOT_PBAR_VS_ELECTRONS_2D, PLOT_PBAR_VS_ELECTRONS_3D,
    PLOT_ANIMATION_2D, PLOT_ANIMATION_3D, ANIMATION_FPS, ANIMATION_FRAME_SKIP
)

# --- Matplotlib Style Settings ---
plt.rcParams['mathtext.fontset'] = 'cm'
plt.rcParams['figure.figsize'] = (12, 8)
plt.rcParams['font.family'] = 'serif'
plt.rcParams['font.weight'] = 'normal'
plt.rcParams['font.size'] = 20 # Slightly smaller default for potentially more labels
plt.rcParams['axes.labelsize'] = 22
plt.rcParams['legend.fontsize'] = 18
plt.rcParams['xtick.labelsize'] = 18
plt.rcParams['ytick.labelsize'] = 18
plt.rcParams['xtick.major.size'] = 7
plt.rcParams['xtick.major.width'] = 1.5
plt.rcParams['ytick.major.size'] = 7
plt.rcParams['ytick.major.width'] = 1.5
plt.rcParams['lines.linewidth'] = 2.5
plt.rcParams['grid.linestyle'] = '--'
plt.rcParams['grid.linewidth'] = 0.7
plt.rcParams['xtick.direction'] = 'in'
plt.rcParams['ytick.direction'] = 'in'
plt.rcParams['axes.linewidth'] = 1.5
plt.rcParams['figure.facecolor'] = 'white'
plt.rcParams['text.usetex'] = False # Set to True if LaTeX is installed and preferred

# --- Helper function to create output directory ---
def ensure_dir(directory_path):
    if not os.path.exists(directory_path):
        os.makedirs(directory_path)
    return directory_path

# --- Main Script ---
if __name__ == "__main__":
    # Construct full path to the CSV file
    csv_file_path = os.path.join(BASE_RESULTS_DIR, TRAJECTORY_CSV_FILENAME)
    
    # Create a specific output directory for this file's plots
    plot_subdir_name = os.path.splitext(TRAJECTORY_CSV_FILENAME)[0]
    plot_output_dir = ensure_dir(os.path.join(PLOT_OUTPUT_DIR_PREFIX, plot_subdir_name))

    if not os.path.exists(csv_file_path):
        print(f"Error: Trajectory CSV file not found at {csv_file_path}")
        exit()

    print(f"Analyzing trajectory data from: {csv_file_path}")

    # --- Parse CSV ---
    # The CSV format is: time, r_p, r_e1, r_e2, ...
    # Or, if it contains full x,y,z data, the parsing needs to be more complex.
    # Assuming the CSV generated by your v3_ccs_run.py which saves:
    # 'time', 'r_p' (modulus), 'r_e1' (modulus), 'r_e2' (modulus)...
    
    times = []
    pbar_radii = []
    electron_radii_cols = [] # List of lists, one for each electron

    try:
        with open(csv_file_path, newline='', encoding='utf-8') as f:
            reader = csv.reader(f)
            header = next(reader) # Read the header row
            
            time_idx = header.index('time')
            r_p_idx = header.index('r_p')
            
            # Dynamically find electron columns
            e_cols_indices = []
            e_labels = []
            for i, col_name in enumerate(header):
                if col_name.startswith('r_e'):
                    e_cols_indices.append(i)
                    e_labels.append(col_name) # Should be 'r_e1', 'r_e2', etc.
                    electron_radii_cols.append([])
            
            num_electrons_from_csv = len(e_cols_indices)
            if num_electrons_from_csv == 0 and len(header) > 2 : # Fallback if no 'r_e' prefix but extra cols
                print("Warning: No columns found with 'r_e' prefix. Assuming remaining columns are electron radii.")
                for i in range(2, len(header)):
                    e_cols_indices.append(i)
                    e_labels.append(f"Electron {i-1}") # Generic label
                    electron_radii_cols.append([])
                num_electrons_from_csv = len(e_cols_indices)


            for row in reader:
                times.append(float(row[time_idx]))
                pbar_radii.append(float(row[r_p_idx]))
                for i, col_idx in enumerate(e_cols_indices):
                    electron_radii_cols[i].append(float(row[col_idx]))

        t_arr = np.array(times)
        r_p_arr = np.array(pbar_radii)
        electron_radii_arrs = [np.array(col) for col in electron_radii_cols]
        e_num = num_electrons_from_csv

        print(f"Successfully parsed {len(t_arr)} time steps for {e_num} electrons and 1 antiproton.")

    except Exception as e:
        print(f"Error parsing CSV file {csv_file_path}: {e}")
        print("Please ensure the CSV format is: time,r_p,r_e1,r_e2,... with a header row.")
        exit()

    # --- Plot 1: All Radial Distances vs. Time ---
    if PLOT_ALL_RADII and e_num > 0:
        plt.figure(figsize=(14, 8))
        plt.plot(t_arr, r_p_arr, label='Antiproton ($r_p$)', color='black', linewidth=3)
        
        linestyles = ['-', '--', '-.', ':', (0, (3, 1, 1, 1)), (0, (1, 1))]
        colors = plt.cm.viridis(np.linspace(0, 0.8, e_num)) # Get distinct colors

        for i in range(e_num):
            plt.plot(t_arr, electron_radii_arrs[i], label=f'{e_labels[i]}', 
                     linestyle=linestyles[i % len(linestyles)], 
                     color=colors[i],
                     linewidth=2)
        
        plt.xlabel(r'Time ($t$) [a.u.]')
        plt.ylabel(r'Radial Distance from Origin ($r$) [a.u.]')
        plt.title('Particle Radial Distances vs. Time')
        plt.legend(loc='upper right')
        plt.grid(True, which='both', linestyle='--', linewidth=0.7, alpha=0.7)
        plt.tick_params(axis='both', which='both', direction='in', top=True, right=True)
        plt.tight_layout()
        plt.savefig(os.path.join(plot_output_dir, 'all_radial_distances.png'))
        plt.savefig(os.path.join(plot_output_dir, 'all_radial_distances.svg'))
        print(f"Plot 'all_radial_distances.png' saved to {plot_output_dir}")
        plt.close()

    # Note: Plotting 2D/3D trajectories and animations requires x,y,z coordinates,
    # not just radial distances. If your CSV from v3_ccs_run.py only saves moduli (r_p, r_e1, ...),
    # you cannot create these trajectory plots directly from it.
    # You would need to modify v3_ccs_run.py to save the full Cartesian
    # y_arr (state vectors) or at least the x,y,z components for each particle at each time step.

    # Assuming for now that future CSVs might contain x,y,z data or you'll adapt this part:
    # The following sections for 2D/3D plots and animations would need access to
    # sol.y[-6:-3, :] for pbar x,y,z and sol.y[3*i:3*(i+1), :] for electron i x,y,z.
    # If your current CSV doesn't have this, these plots will fail or need to be skipped.
    
    # Placeholder for loading full state if available (e.g., from a .npz file like in v2_multi_plots)
    # For now, we'll skip these if only radial data is present.
    full_state_data_available = False 
    # To enable these, you'd load an npz like:
    # try:
    #     full_data = np.load(os.path.join(BASE_RESULTS_DIR, 'full_trajectory_data.npz')) # Or similar
    #     y_arr_full = full_data['y_arr'] # Shape: (total_coords, n_times)
    #     e_num_full = int((y_arr_full.shape[0] - 6) / 6) # pbar has 6 coords (r,p)
    #     t_arr_full = full_data['t_arr']
    #     full_state_data_available = True
    #     print("Full state data (.npz) loaded for detailed trajectory plots.")
    # except FileNotFoundError:
    #     print("Warning: Full state data (.npz) not found. Skipping 2D/3D trajectory plots and animations.")
    #     print("         These plots require Cartesian x,y,z coordinates for each particle.")


    if full_state_data_available:
        # Extract Cartesian coordinates
        # Antiproton:
        r_pbar_cart_t = y_arr_full[-6:-3, :] # x,y,z of pbar over time
        # Electrons:
        r_elec_cart_t = []
        for i in range(e_num_full):
            r_elec_cart_t.append(y_arr_full[3*i : 3*(i+1), :])

        # --- Plot 2: Pbar vs Electrons 2D Trajectory (XY plane) ---
        if PLOT_PBAR_VS_ELECTRONS_2D:
            plt.figure(figsize=(10, 10))
            plt.plot(r_pbar_cart_t[0,:], r_pbar_cart_t[1,:], label='Antiproton Trajectory (XY)', color='black', linewidth=2)
            plt.plot(r_pbar_cart_t[0,0], r_pbar_cart_t[1,0], 'ko', markersize=8, label='Pbar Start')
            plt.plot(r_pbar_cart_t[0,-1], r_pbar_cart_t[1,-1], 'kx', markersize=10, mew=2, label='Pbar End')

            colors = plt.cm.rainbow(np.linspace(0, 1, e_num_full))
            for i in range(e_num_full):
                plt.plot(r_elec_cart_t[i][0,:], r_elec_cart_t[i][1,:], 
                         label=f'Electron {i+1} (XY)', color=colors[i], linestyle='--')
                plt.plot(r_elec_cart_t[i][0,0], r_elec_cart_t[i][1,0], 'o', color=colors[i], markersize=6)
            
            plt.plot(0,0, 'ro', markersize=10, label='Nucleus (Origin)') # Nucleus
            plt.xlabel('X [a.u.]')
            plt.ylabel('Y [a.u.]')
            plt.title('Antiproton and Electron Trajectories (XY Plane)')
            plt.legend(fontsize=12)
            plt.grid(True, alpha=0.5)
            plt.axis('equal')
            plt.tight_layout()
            plt.savefig(os.path.join(plot_output_dir, 'pbar_electron_traj_2D.png'))
            print(f"Plot 'pbar_electron_traj_2D.png' saved to {plot_output_dir}")
            plt.close()

        # --- Plot 3: Pbar vs Electrons 3D Trajectory ---
        if PLOT_PBAR_VS_ELECTRONS_3D:
            fig = plt.figure(figsize=(12, 10))
            ax = fig.add_subplot(111, projection='3d')
            ax.plot(r_pbar_cart_t[0,:], r_pbar_cart_t[1,:], r_pbar_cart_t[2,:], 
                    label='Antiproton Trajectory', color='black', linewidth=2)
            ax.scatter(r_pbar_cart_t[0,0], r_pbar_cart_t[1,0], r_pbar_cart_t[2,0], 
                       c='black', marker='o', s=100, label='Pbar Start', depthshade=True)
            ax.scatter(r_pbar_cart_t[0,-1], r_pbar_cart_t[1,-1], r_pbar_cart_t[2,-1], 
                       c='black', marker='x', s=150, label='Pbar End', depthshade=True)

            colors = plt.cm.rainbow(np.linspace(0, 1, e_num_full))
            for i in range(e_num_full):
                ax.plot(r_elec_cart_t[i][0,:], r_elec_cart_t[i][1,:], r_elec_cart_t[i][2,:],
                        label=f'Electron {i+1}', color=colors[i], linestyle='--')
                ax.scatter(r_elec_cart_t[i][0,0], r_elec_cart_t[i][1,0], r_elec_cart_t[i][2,0], 
                           c=[colors[i]], marker='o', s=50, depthshade=True)
            
            ax.scatter(0,0,0, c='red', marker='o', s=150, label='Nucleus', depthshade=True) # Nucleus
            ax.set_xlabel('X [a.u.]', labelpad=10)
            ax.set_ylabel('Y [a.u.]', labelpad=10)
            ax.set_zlabel('Z [a.u.]', labelpad=10)
            ax.set_title('Antiproton and Electron Trajectories (3D)')
            ax.legend(fontsize=12)
            # Determine appropriate limits for 3D plot
            all_coords = np.concatenate([r_pbar_cart_t] + r_elec_cart_t, axis=1)
            max_range = np.max(all_coords) - np.min(all_coords)
            mid_x = (np.max(all_coords[0,:]) + np.min(all_coords[0,:])) * 0.5
            mid_y = (np.max(all_coords[1,:]) + np.min(all_coords[1,:])) * 0.5
            mid_z = (np.max(all_coords[2,:]) + np.min(all_coords[2,:])) * 0.5
            ax.set_xlim(mid_x - max_range * 0.6, mid_x + max_range * 0.6)
            ax.set_ylim(mid_y - max_range * 0.6, mid_y + max_range * 0.6)
            ax.set_zlim(mid_z - max_range * 0.6, mid_z + max_range * 0.6)

            plt.tight_layout()
            plt.savefig(os.path.join(plot_output_dir, 'pbar_electron_traj_3D.png'))
            print(f"Plot 'pbar_electron_traj_3D.png' saved to {plot_output_dir}")
            plt.close()

        # --- Animation 2D (XY plane) ---
        if PLOT_ANIMATION_2D:
            fig_anim_2d, ax_anim_2d = plt.subplots(figsize=(10,10))
            
            pbar_line, = ax_anim_2d.plot([], [], lw=2, color='black', label='Antiproton')
            pbar_head, = ax_anim_2d.plot([], [], 'o', color='black', markersize=8)
            
            electron_lines = []
            electron_heads = []
            colors = plt.cm.rainbow(np.linspace(0, 1, e_num_full))
            for i in range(e_num_full):
                line, = ax_anim_2d.plot([], [], lw=1.5, color=colors[i], linestyle='--', label=f'Electron {i+1}')
                electron_lines.append(line)
                head, = ax_anim_2d.plot([], [], 'o', color=colors[i], markersize=6)
                electron_heads.append(head)

            ax_anim_2d.plot(0,0, 'ro', markersize=10, label='Nucleus') # Nucleus

            # Determine plot limits from full trajectory
            all_x = np.concatenate([r_pbar_cart_t[0,:]] + [r_elec_cart_t[i][0,:] for i in range(e_num_full)])
            all_y = np.concatenate([r_pbar_cart_t[1,:]] + [r_elec_cart_t[i][1,:] for i in range(e_num_full)])
            lim_min_x, lim_max_x = np.min(all_x), np.max(all_x)
            lim_min_y, lim_max_y = np.min(all_y), np.max(all_y)
            margin_x = (lim_max_x - lim_min_x) * 0.1
            margin_y = (lim_max_y - lim_min_y) * 0.1
            ax_anim_2d.set_xlim(lim_min_x - margin_x, lim_max_x + margin_x)
            ax_anim_2d.set_ylim(lim_min_y - margin_y, lim_max_y + margin_y)
            ax_anim_2d.set_xlabel("X [a.u.]")
            ax_anim_2d.set_ylabel("Y [a.u.]")
            ax_anim_2d.set_title("2D Trajectory Animation (XY Plane)")
            ax_anim_2d.legend(fontsize=10)
            ax_anim_2d.grid(True, alpha=0.5)
            ax_anim_2d.set_aspect('equal', adjustable='box')

            time_template = 'Time = %.2f a.u.'
            time_text_anim = ax_anim_2d.text(0.05, 0.95, '', transform=ax_anim_2d.transAxes)

            num_frames_anim = len(t_arr_full) // ANIMATION_FRAME_SKIP

            def init_anim_2d():
                pbar_line.set_data([], [])
                pbar_head.set_data([], [])
                for line in electron_lines: line.set_data([], [])
                for head in electron_heads: head.set_data([], [])
                time_text_anim.set_text('')
                return [pbar_line, pbar_head] + electron_lines + electron_heads + [time_text_anim]

            def animate_2d(i_frame):
                actual_idx = i_frame * ANIMATION_FRAME_SKIP
                pbar_line.set_data(r_pbar_cart_t[0, :actual_idx+1], r_pbar_cart_t[1, :actual_idx+1])
                pbar_head.set_data(r_pbar_cart_t[0, actual_idx], r_pbar_cart_t[1, actual_idx])
                for j, line in enumerate(electron_lines):
                    line.set_data(r_elec_cart_t[j][0, :actual_idx+1], r_elec_cart_t[j][1, :actual_idx+1])
                    electron_heads[j].set_data(r_elec_cart_t[j][0, actual_idx], r_elec_cart_t[j][1, actual_idx])
                time_text_anim.set_text(time_template % t_arr_full[actual_idx])
                return [pbar_line, pbar_head] + electron_lines + electron_heads + [time_text_anim]

            ani_2d = animation.FuncAnimation(fig_anim_2d, animate_2d, frames=num_frames_anim,
                                             init_func=init_anim_2d, blit=True, interval=1000/ANIMATION_FPS)
            
            anim_2d_path = os.path.join(plot_output_dir, 'trajectory_animation_2D.gif')
            ani_2d.save(anim_2d_path, writer='pillow', fps=ANIMATION_FPS)
            print(f"Animation 'trajectory_animation_2D.gif' saved to {plot_output_dir}")
            plt.close(fig_anim_2d)


        # --- Animation 3D --- (Similar structure to 2D, but with 3D projection)
        if PLOT_ANIMATION_3D:
            # ... (Implementation similar to your v2_multi_plots.py's 3D animation)
            # ... This would involve fig.add_subplot(projection='3d')
            # ... line.set_data_3d(), marker.set_data_3d()
            print("3D Animation plotting is extensive, adapt from v2_multi_plots.py if needed.")
            pass

    else: # if not full_state_data_available
        if PLOT_PBAR_VS_ELECTRONS_2D or PLOT_PBAR_VS_ELECTRONS_3D or PLOT_ANIMATION_2D or PLOT_ANIMATION_3D:
            print("\nSkipping 2D/3D trajectory plots and animations because the input CSV")
            print("appears to contain only radial distances (r_p, r_e1, ...).")
            print("To generate these plots, the CSV (or a supplementary .npz file)")
            print("must contain the full Cartesian (x,y,z) coordinates for each particle over time.")

    print(f"\nAll requested plots saved in directory: {plot_output_dir}")
